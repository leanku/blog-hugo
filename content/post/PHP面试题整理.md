---
title: "PHP面试题整理"
date: 2024-02-20T20:46:01+08:00
draft: false
categories: ["PHP"]
tags: ["PHP","面试题"]
keywords: ["PHP","面试题"]
---


# PHP常用函数整理

1. **什么事面向对象？主要特征是什么？**
   
    面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态。

2. **SESSION 与 COOKIE的区别是什么，请从协议，产生的原因与作用说明?**
   
   A、http无状态协议，不能区分用户是否是从同一个网站上来的，同一个用户请求不同的页面不能看做是同一个用户。B、SESSION存储在服务器端，COOKIE保存在客户端。Session比较安全，cookie用某些手段可以修改，不安全。Session依赖于cookie进行传递。禁用cookie后，session不能正常使用。Session的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。Session保存在服务器端的文件或数据库中，默认保存在文件中，文件路径由php配置文件的session.save_path指定。Session文件是公有的。

3. **HTTP 状态中302、403、 500代码含义？**
   
    一二三四五原则:（即一：消息系列；二：成功系列；三：重定向系列；四：请求错误系列；五：服务器端错误系列。）  
    302:临时转移成功，请求的内容已转移到新位置  
    403:禁止访问  
    500:服务器内部错误 401：代表未授权。

4. **请写出数据类型(int char varchar datetime text)的意思；请问 varchar 和 char有什么区别？**
   
   Int 整数char 定长字符 Varchar 变长字符 Datetime 日期时间型Text 文本型 Varchar与char的区别 char是固定长度的字符类型，分配多少空间，就占用多长空间。Varchar是可变长度的字符类型，内容有多大就占用多大的空间，能有效节省空间。由于varchar类型是可变的，所以在数据长度改变的时，服务器要进行额外的操作，所以效率比char类型低。

5. **MyISAM和 InnoDB 的基本区别？索引结构如何实现？**
   
   A、MyISAM类型不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，适合用于频繁查询的应用；  
   B、InnoDB类型支持事务，行锁，有崩溃恢复能力，读写速度比MyISAM慢，适合于插入和更新操作比较多的应用，空间占用大，不支持全文索引等。创建索引：alert table tablename add index 索引名 (`字段名`)

6. **isset() 和 empty() 区别** 
   
   isset判断变量是否存在，可以传入多个变量，若其中一个变量不存在则返回假；empty判断变量是否为空为假，只可传一个变量，如果为空为假则返回真。

7. **请说明 PHP 中传值与传引用的区别。什么时候传值什么时候传引用？**
   
   按值传递：函数范围内对值的任何改变在函数外部都会被忽略按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。

8. **在PHP中error_reporting这个函数有什么作用？**  
   
    设置PHP的报错级别并返回当前级别。

9.  **现在编程中经常采取MVC三层结构，请问MVC分别指哪三层，有什么优点？**  

    MVC三层分别指：业务模型、视图、控制器，由控制器层调用模型处理数据，然后将数据映射到视图层进行显示，优点是：①可以实现代码的重用性，避免产生代码冗余；②M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式

10. **在程序的开发中，如何提高程序的运行效率？**

    A、优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询；  
    B、数据表中创建索引；  
    C、对程序中经常用到的数据生成缓存。  
    
11. **语句include和require的区别是什么?为避免多次包含同一文件，可用什么语句代替它们?**  
    区别：在失败的时候：include产生一个warning，而require产生直接产生错误中断require在运行前载入include在运行时载入代替：require_once,include_once

12. **简述php的垃圾收集机制。**
    
    php中的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为0时，就回收该变量容器。如果一个zval的refcount减1之后大于0，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理。

13. **什么是 CSRF 攻击 ？XSS 攻击？如何防范？**

    CSRF，跨站请求伪造，攻击方伪装用户身份发送请求从而窃取信息或者破坏系统。讲述基本原理：用户访问A网站登陆并生成了cookie，再访问B网站，如果A网站存在CSRF漏洞，此时B网站给A网站的请求（此时相当于是用户访问），A网站会认为是用户发的请求，从而B网站就成功伪装了你的身份，因此叫跨站脚本攻击。

    CSRF防范：A、合理规范api请求方式，GET，POSTB、对POST请求加token令牌验证，生成一个随机码并存入session，表单中带上这个随机码，提交的时候服务端进行验证随机码是否相同。

    XSS，跨站脚本攻击。

    防范：不相信任何输入，过滤输入。

14. **什么是事务？及其特性？**
    
    答：事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。

    事务特性：A、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。B、一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态C、隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，D、持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

    或者这样理解：事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。

15. **什么是锁？**
    
    答：数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

    加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。

    基本锁类型：锁包括行级锁和表级锁

16. **索引的作用？和它的优点缺点是什么？**
    
    索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。

17. **堆和栈的区别？**

    A、堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小；

    B、栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义。
18. **__autoload()方法的工作原理是什么？**
    
    使用这个魔术函数的基本条件是类文件的文件名要和类的名字保持一致。

    当程序执行到实例化某个类的时候，如果在实例化前没有引入这个类文件，那么就自动执行__autoload()函数。

    这个函数会根据实例化的类的名称来查找这个类文件的路径，当判断这个类文件路径下确实存在这个类文件后

    就执行include或者require来载入该类，然后程序继续执行，如果这个路径下不存在该文件时就提示错误。

    使用自动载入的魔术函数可以不必要写很多个include或者require函数。

19. **简述高并发网站解决方案。**
    
    A、前端优化（CND加速、建立独立图片服务器）

    B、服务端优化（页面静态化、并发处理[异步|多线程]、队列处理）

    C、数据库优化（数据库缓存[Memcachaed|Redis]、读写分离、分库分表、分区）
    
    D、Web服务器优化（负载均衡、反向代理）

20. **怎么防止sql注入？**
    
    1）过滤掉一些常见的数据库操作关键字：select,insert,update,delete,and,*等，或者通过系统函数：addslashes(需要被过滤的内容)来进行过滤。

    2）在PHP配置文件中

    Register_globals=off;设置为关闭状态 //作用将注册全局变量关闭。

    比如：接收POST表单的值使用$_POST['user'],如果将register_globals=on;直接使用$user可以接收表单的值。

    3）SQL语句书写的时候尽量不要省略小引号(tab键上面那个)和单引号

    4）提高数据库命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的

    5）对于常用的方法加以封装，避免直接暴漏SQL语句

    6）开启PHP安全模式

    Safe_mode=on;

    7）打开magic_quotes_gpc来防止SQL注入

    Magic_quotes_gpc=off;默认是关闭的，它打开后将自动把用户提交的sql语句的查询进行转换，把'转为\'，这对防止sql注入有重大作用。

    因此开启：magic_quotes_gpc=on;

    8）控制错误信息

    关闭错误提示信息，将错误信息写到系统日志。

    9）使用mysqli或pdo预处理。

21. **redis 常见问题及解决方案**
    
    1、缓存雪崩：同一时间大量缓存失效，导致请求直接查询数据库，数据库内存和CPU压力增加甚至宕机  
    解决：  
    热点数据永不过期或者分布到不同实例，降低单机故障问题  
    缓存时间添加随机数，防止大量缓存同时失效                
    做二级缓存或者双缓存，A为原始缓存 短时效，B为备份缓存 ，长期有效。更新时候双写缓存  

    2、缓存穿透：缓存和数据库都没有数据，大量请求下，所有请求直接击穿到数据库，导致宕机。  
    解决：  
    布隆过滤器:长度为m的位向量或者位列表组成（仅包含0或1位值的列表）  
    使用多个不用的hash函数，产生多个索引值，填充对应多个位置的值为1  
    布隆过滤器可以检查值是 “可能在集合中” 还是 “绝对不在集合中”  
    可能误判但是基础过滤效率高  
    极端情况，当布隆过滤器没有空闲位置的时候每次查询返回true  
    空缓存（短时效）  
    业务层参数过滤  

    3、缓存击穿：数据库中有数据，但是缓存突然失效之后发生大量请求导致数据库压力增加甚至打垮宕机

    解决：
    热点数据永不过期  
    互斥锁：获取锁之后不管成功还是失败都要释放锁  

22. **数据库优化策略？**
    
    1.合理的表设计。

        1.依据三范式，设计表.

        ​ 三范式：1.原子性，每个字段都是不可在分的。

        ​ 2.在1方式的基础上，表中每一列必须有唯一性，其他字段依赖主键。

        ​ 3.在2方式的基础上，表中的每一列只与主键直接相关，而不是间接相关。

        ​ 2.选择合适的字段。

        ​ I.尽量使用TYPEINT、SMALLINT、MEDIUM_INT代替INT的使用，一般索引，并且是字段递增，可以考虑设置为UNSIGNED.

        ​ II.使用枚举代替字符串类型。

        ​ III.将少null的使用，null很难优化，并且还占用额外的空间。

        ​ iv.varchar长度分配给真正需要的空间。

        v.建立合适的索引。

        3）选择合适的引擎。

2.sql优化

    ​ 1.减少*的使用，只查询需要的字段。

     2.使用关联查询，代替子查询。

    ​ 3.like使用后匹配。

    ​ 4.合理使用索引。

     5.减少对null字段的判断、否则引擎放弃索引，对全表进行扫描。

    ​ 6.减少！=，<>的使用。

    ​ 7.减少where 条件中使用or来连接条件

    select id from t where num=10 or Name = ‘admin’ #可以这样查询： select id from t where num = 10 union select id from t where Name = ‘admin’
3.减少数据库访问的次数。

    1.将不经常变化的数据，进行缓存（分类、权限等），可以使用redis和mememcha,我个人建议，不要使用文件缓存，它也是对iO进行操作。

4.硬件方面。

    ​ 1.可以考虑分库、分表。

    ​ 2.可以采用主从复制，读写分离.（mysql服务器根据sql，去判断是读还是写
